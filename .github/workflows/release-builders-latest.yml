name: Release Builders (Latest)

on:
  workflow_dispatch:
    inputs:
      publish_scope:
        description: 'What to publish'
        required: true
        default: 'changed'
        type: choice
        options:
          - changed          # Only changed packages (auto-detect)
          - all              # All builders packages
          - templates        # All base templates
          - packages         # All package addons
          - categories       # All category packages
          - custom           # Manual selection
      
      version_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch  # 0.0.x (bug fixes)
          - minor  # 0.x.0 (new features)
          - major  # x.0.0 (breaking changes)
      
      custom_packages:
        description: 'Comma-separated package dirs (for custom mode, e.g., "template/nextjs,packages/nextjs/eslint")'
        required: false
        type: string
      
      dry_run:
        description: 'Dry run (skip actual publishing)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: read

jobs:
  detect-and-publish:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.14.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Discover builders packages
        id: discover
        run: |
          set -x  # Enable verbose mode
          echo "Discovering builders packages..."
          echo "Current directory: $(pwd)"
          echo "Listing builders directory:"
          ls -la builders/ || echo "builders directory not found"
          
          # Function to get package info using Node.js
          get_package_info() {
            local pkg_dir=$1
            local config_file="$pkg_dir/config.json"
            local package_file="$pkg_dir/package.json"
            
            echo "  Checking: $pkg_dir"
            
            if [ ! -f "$config_file" ]; then
              echo "    Config not found: $config_file"
              return 1
            fi
            
            if [ ! -f "$package_file" ]; then
              echo "    Package.json not found: $package_file"
              return 1
            fi
            
            # Check if ready using Node.js with absolute path
            local ready=$(node -e "const fs=require('fs'); const config=JSON.parse(fs.readFileSync('$config_file','utf8')); console.log(config.ready || false);" 2>&1)
            echo "    Ready status: $ready"
            
            if [ "$ready" != "true" ]; then
              echo "    Package not ready, skipping"
              return 1
            fi
            
            # Get package name and version using Node.js with absolute path
            local name=$(node -e "const fs=require('fs'); const pkg=JSON.parse(fs.readFileSync('$package_file','utf8')); console.log(pkg.name);")
            local version=$(node -e "const fs=require('fs'); const pkg=JSON.parse(fs.readFileSync('$package_file','utf8')); console.log(pkg.version);")
            
            echo "    Found: $name@$version"
            echo "$pkg_dir|$name|$version"
          }
          
          # Discover all packages
          packages=()
          
          # Base templates
          echo "Scanning base templates..."
          for dir in builders/template/*/; do
            if [[ "$(basename "$dir")" != _* ]]; then
              info=$(get_package_info "$dir" 2>&1 | tail -n 1)
              if [[ $info == *"|"* ]]; then
                packages+=("$info")
              fi
            fi
          done
          
          # Package addons (nested structure: builders/packages/framework/package/)
          echo "Scanning package addons..."
          for dir in builders/packages/*/*/; do
            if [[ "$(basename "$(dirname "$dir")")" != _* ]] && [[ "$(basename "$dir")" != _* ]]; then
              info=$(get_package_info "$dir" 2>&1 | tail -n 1)
              if [[ $info == *"|"* ]]; then
                packages+=("$info")
              fi
            fi
          done
          
          # Categories
          echo "Scanning categories..."
          for dir in builders/categories/*/; do
            if [[ "$(basename "$dir")" != _* ]]; then
              info=$(get_package_info "$dir" 2>&1 | tail -n 1)
              if [[ $info == *"|"* ]]; then
                packages+=("$info")
              fi
            fi
          done
          
          # Save all packages
          printf '%s\n' "${packages[@]}" > all_packages.txt
          echo "Found ${#packages[@]} ready packages"
          cat all_packages.txt

      - name: Detect changed packages
        id: changes
        run: |
          # Get last release tag
          LAST_TAG=$(git tag --sort=-version:refname | grep -E '^builders/' | head -n 1)
          
          if [ -z "$LAST_TAG" ]; then
            echo "No previous builders release found, will publish all packages"
            cp all_packages.txt changed_packages.txt
          else
            echo "Last builders release: $LAST_TAG"
            
            # Get changed files since last tag
            changed_files=$(git diff --name-only "$LAST_TAG" HEAD | grep '^builders/')
            
            # Filter packages that have changes
            > changed_packages.txt
            while IFS='|' read -r pkg_dir pkg_name pkg_version; do
              if echo "$changed_files" | grep -q "^$pkg_dir/"; then
                echo "$pkg_dir|$pkg_name|$pkg_version" >> changed_packages.txt
              fi
            done < all_packages.txt
          fi
          
          echo "Changed packages:"
          cat changed_packages.txt

      - name: Select packages to publish
        id: select
        run: |
          scope="${{ github.event.inputs.publish_scope }}"
          
          case "$scope" in
            all)
              echo "Publishing all packages"
              cp all_packages.txt selected_packages.txt
              ;;
            changed)
              echo "Publishing changed packages"
              cp changed_packages.txt selected_packages.txt
              ;;
            templates)
              echo "Publishing all templates"
              grep '^builders/template/' all_packages.txt > selected_packages.txt || touch selected_packages.txt
              ;;
            packages)
              echo "Publishing all package addons"
              grep '^builders/packages/' all_packages.txt > selected_packages.txt || touch selected_packages.txt
              ;;
            categories)
              echo "Publishing all categories"
              grep '^builders/categories/' all_packages.txt > selected_packages.txt || touch selected_packages.txt
              ;;
            custom)
              echo "Custom selection: ${{ github.event.inputs.custom_packages }}"
              > selected_packages.txt
              IFS=',' read -ra DIRS <<< "${{ github.event.inputs.custom_packages }}"
              for dir in "${DIRS[@]}"; do
                dir=$(echo "$dir" | xargs)  # trim whitespace
                grep "^builders/$dir|" all_packages.txt >> selected_packages.txt || true
              done
              ;;
          esac
          
          count=$(wc -l < selected_packages.txt)
          echo "Selected $count packages to publish"
          cat selected_packages.txt
          
          if [ "$count" -eq 0 ]; then
            echo "No packages selected for publishing"
            echo "HAS_PACKAGES=false" >> $GITHUB_OUTPUT
          else
            echo "HAS_PACKAGES=true" >> $GITHUB_OUTPUT
          fi

      - name: Bump versions
        if: steps.select.outputs.HAS_PACKAGES == 'true'
        id: bump
        run: |
          version_type="${{ github.event.inputs.version_type }}"
          
          echo "Bumping versions (type: $version_type)"
          WORKSPACE_ROOT=$(pwd)
          version_changes=""
          
          while IFS='|' read -r pkg_dir pkg_name pkg_version; do
            echo "Processing $pkg_name (current: $pkg_version)"
            
            pkg_json="$WORKSPACE_ROOT/$pkg_dir/package.json"
            
            # Check if current version is a canary/pre-release
            if [[ $pkg_version == *"-"* ]]; then
              echo "  Pre-release version detected, promoting to stable"
              
              # Strip pre-release suffix (e.g., -canary.2, -alpha.1, etc.)
              new_version=$(echo "$pkg_version" | sed 's/-.*$//')
              
              # Update to stable version (no bumping)
              node -e "const fs=require('fs');const pkg=JSON.parse(fs.readFileSync('$pkg_json','utf8'));pkg.version='$new_version';fs.writeFileSync('$pkg_json',JSON.stringify(pkg,null,2)+'\n');"
              
              echo "  Promoted to stable: $new_version"
            else
              # Stable to stable: bump version normally
              cd "$pkg_dir"
              new_version=$(npm version "$version_type" --no-git-tag-version)
              new_version=${new_version#v}  # Remove 'v' prefix
              cd "$WORKSPACE_ROOT"
              
              echo "  Bumped to: $new_version"
            fi
            
            version_changes="${version_changes}${pkg_dir}|${pkg_name}|${pkg_version}|${new_version}"$'\n'
          done < selected_packages.txt
          
          # Save to GITHUB_ENV for next steps
          echo "VERSION_CHANGES<<EOF" >> $GITHUB_ENV
          echo "$version_changes" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          
          echo "Version changes:"
          echo "$version_changes"

      - name: Cleanup temporary files
        if: steps.select.outputs.HAS_PACKAGES == 'true'
        run: |
          # Clean up temporary files before committing
          rm -f all_packages.txt changed_packages.txt selected_packages.txt

      - name: Commit version changes
        if: steps.select.outputs.HAS_PACKAGES == 'true' && github.event.inputs.dry_run != 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Add all changed package.json files
          while IFS='|' read -r pkg_dir pkg_name old_version new_version; do
            git add "$pkg_dir/package.json"
          done <<< "$VERSION_CHANGES"
          
          git commit -m "chore(builders): bump versions to latest"
          git push

      - name: Create tags
        if: steps.select.outputs.HAS_PACKAGES == 'true' && github.event.inputs.dry_run != 'true'
        run: |
          while IFS='|' read -r pkg_dir pkg_name old_version new_version; do
            tag="$pkg_name@$new_version"
            echo "Creating tag: $tag"
            git tag "$tag"
          done <<< "$VERSION_CHANGES"
          
          git push --tags

      - name: Publish to npm
        if: steps.select.outputs.HAS_PACKAGES == 'true' && github.event.inputs.dry_run != 'true'
        run: |
          while IFS='|' read -r pkg_dir pkg_name old_version new_version; do
            echo "Publishing $pkg_name@$new_version"
            cd "$pkg_dir"
            
            # Publish to npm
            npm publish --access public
            
            cd - > /dev/null
          done <<< "$VERSION_CHANGES"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Generate release notes
        if: steps.select.outputs.HAS_PACKAGES == 'true' && github.event.inputs.dry_run != 'true'
        id: release_notes
        run: |
          cat > release_notes.md << EOF
          ## Builders Packages Release
          
          ### Published Packages
          
          EOF
          
          while IFS='|' read -r pkg_dir pkg_name old_version new_version; do
            echo "- **$pkg_name**: \`$old_version\` → \`$new_version\`" >> release_notes.md
          done <<< "$VERSION_CHANGES"
          
          cat >> release_notes.md << EOF
          
          ### Installation
          
          \`\`\`bash
          EOF
          
          while IFS='|' read -r pkg_dir pkg_name old_version new_version; do
            echo "npm install $pkg_name@$new_version" >> release_notes.md
          done <<< "$VERSION_CHANGES"
          
          echo "\`\`\`" >> release_notes.md
          
          cat release_notes.md

      - name: Create GitHub Release
        if: steps.select.outputs.HAS_PACKAGES == 'true' && github.event.inputs.dry_run != 'true'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: "builders/v${{ github.run_number }}"
          release_name: "Builders Release #${{ github.run_number }}"
          body_path: release_notes.md
          draft: false
          prerelease: false

      - name: Summary
        if: steps.select.outputs.HAS_PACKAGES == 'true'
        run: |
          echo "## 🎉 Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Published Packages" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Package | Old Version | New Version |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------------|-------------|" >> $GITHUB_STEP_SUMMARY
          
          while IFS='|' read -r pkg_dir pkg_name old_version new_version; do
            echo "| \`$pkg_name\` | $old_version | $new_version |" >> $GITHUB_STEP_SUMMARY
          done <<< "$VERSION_CHANGES"
          
          if [ "${{ github.event.inputs.dry_run }}" == "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "⚠️ **DRY RUN** - No changes were actually published" >> $GITHUB_STEP_SUMMARY
          fi
